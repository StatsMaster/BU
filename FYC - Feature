

/* sample 70% */

/* proc freq data = loc_srs.develop; tables channel*rdc / list ; run ; */

proc surveyselect NoPrint 
	data		= FYC_v3
	out			= loc_srs.develop
	samprate	= .6667
	seed		= 20140719
	outall;
run;

data 	fyc_T
		fyc_V;
 set loc_srs.develop (where=(CHANNEL='ALLI' and RDC ne 'KMS'));
 if Selected = 1 then output FYC_T; else output FYC_V;
run ;

%let dsn = FYC_T ;
%let vds = FYC_V ;

data switchover;
input Rank 3. one 2.;
datalines;
1  1
2  1
3  1
4  1
5  1
6  1
7  1
8  1
9  1
10 1
;
Run;

/* 
	Feature 
  ______         _                  
 |  ____|       | |                 
 | |__ ___  __ _| |_ _   _ _ __ ___ 
 |  __/ _ \/ _` | __| | | | '__/ _ \
 | | |  __/ (_| | |_| |_| | | |  __/
 |_|  \___|\__,_|\__|\__,_|_|  \___|
                                                                        
*/

%macro Feature;

%let var_num_list =PMV PAT Biz_TiY;
%let var_cnt = 3 ;
%do x = 1 %to &var_cnt. ;
%let var = %scan(&var_num_list.,&x.,' ');
%IF &x. = 1 %then %do; 
%let sas_code = 
 Format &var._LN &var._SR &var._X2 &var._X3 &var._IN Comma32.7 %str(;)
 InFormat &var._LN &var._SR &var._X2 &var._X3 &var._IN 32.7 %str(;)
 &var._LN 	=  LOG(&var.) %STR(;) 		if &var._LN = . then &var._LN = 0 %STR(;)
 &var._SR 	= SQRT(&var.) %STR(;)		if &var._SR = . then &var._SR = 0 %STR(;)
 &var._X2 	=     (&var.)**2 %STR(;)	if &var._X2 = . then &var._X2 = 0 %STR(;)	
 &var._X3 	=     (&var.)**3 %STR(;)	if &var._X3 = . then &var._X3 = 0 %STR(;)
 &var._IN 	=   1/(&var.) %STR(;)		if &var._IN = . then &var._IN = 0 %STR(;) ;
%end;
%IF &x. > 1 %then %do; 
%let sas_code = &sas_code.
 Format &var._LN &var._SR &var._X2 &var._X3 &var._IN Comma32.7 %str(;)
 InFormat &var._LN &var._SR &var._X2 &var._X3 &var._IN 32.7 %str(;)
 &var._LN 	=  LOG(&var.) %STR(;) 		if &var._LN = . then &var._LN = 0 %STR(;)
 &var._SR 	= SQRT(&var.) %STR(;)		if &var._SR = . then &var._SR = 0 %STR(;)
 &var._X2 	=     (&var.)**2 %STR(;)	if &var._X2 = . then &var._X2 = 0 %STR(;)	
 &var._X3 	=     (&var.)**3 %STR(;)	if &var._X3 = . then &var._X3 = 0 %STR(;)
 &var._IN 	=   1/(&var.) %STR(;)		if &var._IN = . then &var._IN = 0 %STR(;)
;
%end;
%end;
%Put the SAS code is &sas_code. ;
data &dsn. ; set &dsn. ; &sas_code.  run;
data &vds. ; set &vds. ; &sas_code.  run;

%let var_num_list =PMV PAT Biz_TiY;
%let var_cnt = 3 ;
%do x = 1 %to &var_cnt. ;
%let var = %scan(&var_num_list.,&x.,' ');

/* 		Disceretization Process #1
Generating ordinal groupings of equal widths
and for each catigories the odds ratio. */

/* Update needed to generalized cut points -- watch */

%let in_dsn = &dsn. ;
%let rspn   = quick_close ;

proc univariate data=&in_dsn. ; 
	VAR &var. ;
	histogram &var / midpercents NMIDPOINTS = 20 ;
	ods output HistogramBins = HB ;
run ;

proc sql;
	select Midpoint into :MP1-:MP10 from HB ;			
quit;

Data &in_dsn._1;
 set &in_dsn.;
	 if &var. = . then delete;
else if &var. <  &MP1. then &var.ORD = 1;
else if &var. <  &MP2. then &var.ORD = 2;
else if &var. <  &MP3. then &var.ORD = 3;
else if &var. <  &MP4. then &var.ORD = 4;
else if &var. <  &MP5. then &var.ORD = 5;
else if &var. <  &MP6. then &var.ORD = 6;
else if &var. <  &MP7. then &var.ORD = 7;
else if &var. <  &MP8. then &var.ORD = 8;
else if &var. <	 &MP9. then	&var.ORD = 9;
else						&var.ORD = 10;
Run;

/* Create the odds ratio version of the variable */

Proc Summary data = &in_dsn._1 mean missing std;
	class &var.ORD ; var &var.ORD &rspn.;
	output out=summary mean = avg_indp avg_dep;
Run; 

Data summary;
Set summary;
&var.ODS  = log(avg_dep/(1-avg_dep));
&var.ODS1 = (avg_dep/(1-avg_dep)); 
Run;

/* Merge the summary file values back into the dataset */

Proc sort data = summary ; 		by &var.ORD ; Run ;
Proc sort data = &in_dsn._1 ; 	by &var.ORD ; Run ;

Data &in_dsn._2 (drop = _TYPE_ _FREQ_ avg_indp avg_dep);
	Merge &in_dsn._1 summary ; 
	by &var.ORD;
Run;

* apply the rules to the validation dataset ;

proc means data = &in_dsn._2 min max maxdec=0;
	class &var.ORD &var.ODS &var.ODS1 ;
	var  &var. ;
	ods output Summary = rules;
run;

proc sql; select count(*) into :cnt from rules; quit;

data rules2 ;
 set rules ;
 format sas_code $150. ;
 if _n_ = 1 then do;
 sas_code = "if &var. < "||compress(&var._max)||" then do; "||" &var.ORD ="||compress(&var.ORD)||"; &var.ODS ="||compress(&var.ODS)||"; &var.ODS1 ="||compress(&var.ODS1)||"; end;" ; 
 end;
 else  do;
 sas_code = "else if &var. < "||compress(&var._max)||" then do; "||" &var.ORD ="||compress(&var.ORD)||"; &var.ODS ="||compress(&var.ODS)||"; &var.ODS1 ="||compress(&var.ODS1)||"; end;" ; 
 end;
 if _n_ = &cnt. then do;
 sas_code = "else do; "||" &var.ORD ="||compress(&var.ORD)||"; &var.ODS ="||compress(&var.ODS)||"; &var.ODS1 ="||compress(&var.ODS1)||"; end;" ; 
 end;
run;

proc sql; select sas_code into :code seperated by ' ' from rules2; quit;

data &vds.;
 set &vds.;
 &code.
run;

data &dsn.;
 set &dsn.;
 &code.
run;

/* 		Disceretization Process #2
Develop ordinal categories of equal Frequencies */

Proc Rank data = &in_dsn._2 out = ranked groups = 10 ties = high;
	ranks rank; 
	var &var.;
Run;

data ranked;
 set ranked;
 rank=rank+1;
run;

Proc Summary data = ranked missing mean std min max;
	class rank;
	Var &var. &rspn.;
	Output out = summaryrank 
		mean 	= 	avg_indp avg_dep 
		std 	= 	std_indp std_dep 
		min		=	min_indp min_dep 
		max		=	max_indp max_dep;
Run;

Proc Sort data = summaryrank; by Rank; Run;
Proc Sort data = ranked; by Rank; Run;

Data RANKINGFILE; Merge ranked summaryrank; by Rank; Run;

/* Start t-Tests */

proc sort data=summaryrank; by rank; run;

%let pval_col=0.15; 

Data summaryrank;
 Set summaryrank;
 var = "&var.";
 If _TYPE_ = 1;
 rename _freq_ = numobs;
Run;

data temp;
 set summaryrank;
 by var;
 retain 
	_finit 
	_rnk1 
	_rnk2 
	_freq1 
	_freq2 
	_aindp1 
	_aindp2
	_mindp1 
	_mindp2 
	_mxindp1 
	_mxindp2 
	_adep1 
	_adep2 
	_sdep1 
	_sdep2 
	_sdenom1 
	_sdenom2;

   /* 
	Use _finit to flag when first initialization occurs 
   First initialization is when the first non-missing level is 
   encountered. From this point forward the t-tests take place, 
	since missing levels are automatically outputted as their own level 
	*/

   if first.var then _finit = 0;

   /* Rank is missing */
   if rank <= .Z then output;

   else do;
      if _finit=0 then do;
         _finit		=	1;
		 _rnk1		=	rank;
		 _freq1		=	numobs;
		 _aindp1	=	numobs*avg_indp;
         _mindp1	=	min_indp;
         _mxindp1	=	max_indp;
         _adep1		=	numobs*avg_dep;

         if std_dep =	. 	then _sdep1	= 0;
         					else _sdep1	= (numobs-1)*std_dep*std_dep;
         _sdenom1	=	numobs-1;
	end;
	else do;
         _w1		=	(_sdep1/_sdenom1)/_freq1;
         _w2		=	(std_dep**2)/numobs;
         _df		=	((_w1+_w2)**2)/((_w1**2)/(_freq1-1)+(_w2**2)/(numobs-1));
         _t			=	abs(_adep1/_freq1-avg_dep)/sqrt(_w1+_w2);
         pvalue		=	(1-probt(_t,round(_df,1)))*2;
      
	     /* If the t-test is significant, then output cumulated variables
         otherwise continue cumulating */

	if pvalue <= &pval_col. then do;
            /* Store current row */
		_rnk2		=	rank;
		_freq2		=	numobs;
		_aindp2		=	numobs*avg_indp;
        _mindp2		=	min_indp;
        _mxindp2	=	max_indp;
        _adep2		=	numobs*avg_dep;
        if std_dep 	= 	. 	then _sdep2 = 0;
							else _sdep2	= (numobs-1)*std_dep*std_dep;
		_sdenom2	=	numobs-1;

			/* Switch cumulated variables with current row and output */
		rank		=	_rnk1;
		numobs		=	_freq1;
		avg_indp	=	_aindp1/_freq1;
        min_indp	=	_mindp1;
        max_indp	=	_mxindp1;
		avg_dep		=	_adep1/_freq1;
		std_dep		=	sqrt(_sdep1/_sdenom1);
		output;

		/* Set first variables to current row */
		_rnk1		=	_rnk2;
		_freq1		=	_freq2;
		_aindp1		=	_aindp2;
     	_mindp1		=	_mindp2;
		_mxindp1	=	_mxindp2;
		_adep1		=	_adep2;
		_sdep1		=	_sdep2;
		_sdenom1	=	_sdenom2;
		end;
		else do; 
		_rnk1		=	rank;
		_freq1		=	_freq1+numobs;
		_aindp1		=	_aindp1+numobs*avg_indp;
		_mxindp1	=	max_indp;
		_adep1		=	_adep1+numobs*avg_dep;
		if std_dep 	ne 	. then _sdep1=_sdep1+(numobs-1)*std_dep*std_dep;
		_sdenom1	=	_sdenom1+numobs-1;
  		end;

		/* If last row for current variable, then output */

		if last.var then do;
			rank=_rnk1;
           	numobs=_freq1;
           	avg_indp=_aindp1/_freq1;
           	min_indp=_mindp1;
           	max_indp=_mxindp1;
           	avg_dep=_adep1/_freq1;
           	std_dep=sqrt(_sdep1/_sdenom1);
           output;
         end;

      end;
   end;
   drop _finit _rnk1 _rnk2 _freq1 _freq2 _aindp1 _aindp2
        _mindp1 _mindp2 _mxindp1 _mxindp2 _adep1 _adep2
        _sdep1 _sdep2 _sdenom1 _sdenom2 _w1 _w2 _df _t /*pvalue*/;
run;

Data temp;
 set temp;
&var.ODSEQ = log(avg_dep/(1-avg_dep));
&var.ODSEQ1 = (avg_dep/(1-avg_dep));
Run;

Proc sort data=temp; by rank; Run;

/*
data switchover;
input Rank 3. one 2.;
datalines;
1  1
2  1
3  1
4  1
5  1
6  1
7  1
8  1
9  1
10 1
;
Run;
*/

proc sql;
	create table switchover_a as select
	a.rank as a,
	coalesce(b.rank,999) as b
	from switchover a left join (select * from temp where rank ne .) b on a.rank = b.rank;

	select b into :r1-:r10 from switchover_a;
quit;

%Put The rnks are: &r1 &r2 &r3 &r4 &r5 &r6 &r7 &r8 &r9 &r10;

data switchover_b;
 set switchover_a;

 /* 1 */

 if _N_ = 1 then do; if &r1 = 1   then c = 1; end;

 /* 2 */

 if _N_ = 2 then do; if &r2 = 999 then c = 1; else c = 2; end;

 /* 3 */

 		if _N_ = 3 then do; 
		if &r3 =  999 and &r2 =  999  then c = 1;
 else   if &r3 =  999 and &r2 ne 999  then c = 2;
 else	if &r3 ne 999 then c = 3;
 		end;

 /* 4 */

 		if _N_ = 4 then do;
		if &r4 ne 999 then c = 4;
 else   if &r4 =  999 and &r3 ne 999 then c = 3;
 else   if &r4 =  999 and &r3  = 999 and &r2 ne 999 then c = 2;
 else	c = 1;
 		end;

 /* 5 */

 		if _N_ = 5 then do;
		if  &r5 ne 999 then c = 5;
 else   if  &r5 =  999 and &r4 ne 999 then c = 4;
 else   if  &r5 =  999 and &r4  = 999 and &r3 ne 999  then c = 3;
 else	if  &r5 =  999 and &r4  = 999 
		and &r3 = 999  and &r2 ne 999 then c = 2;
 else	c = 1;
 		end;

 /* 6 */

  		if _N_ = 6 then do;
		if  &r6 ne 999 then c = 6;
 else   if  &r6 =  999 and &r5 ne 999 then c = 5;
 else   if  &r6 =  999 and &r5  = 999 and &r4 ne 999  then	c = 4;
 else	if  &r6 =  999 and &r5  = 999 and &r4 = 999  
		and &r3 ne 999	then c = 3;
 else	if  &r6 =  999 and &r5  = 999 and &r4 = 999  
		and &r3 =  999 and &r2 ne 999 then c = 2;
 else	c = 1;
 		end;

 /* 7 */

  		if _N_ = 7 then do; 
		if  &r7 ne 999 then c = 7;
 else   if  &r7 =  999 and &r6 ne 999 then c = 6;
 else   if  &r7 =  999 and &r6  = 999 and &r5 ne 999 then	c = 5;
 else	if  &r7 =  999 and &r6  = 999 and &r5 = 999  
		and &r4 ne 999 then c = 4;
 else	if  &r7 =  999 and &r6  = 999 and &r5 = 999  
		and &r4 =  999 and &r3 ne 999 then c  = 3;
 else	if  &r7 =  999 and &r6  = 999 and &r5 = 999  
		and &r4 =  999 and &r3  = 999 and &r2 ne 999 then c = 2;
 else	c = 1;
 		end;

 /* 8 */

   		if _N_ = 8 then do; 
		if 	&r8 ne 999 then c = 8;
 else   if 	&r8 =  999 and &r7 ne 999 then c = 7;
 else   if 	&r8 =  999 and &r7  = 999 and &r6 ne 999 then c = 6;
 else	if 	&r8 =  999 and &r7  = 999 and &r6 = 999  
		and &r5 ne 999 then c = 5;
 else	if  &r8 =  999 and &r7  = 999 and &r6 = 999  
		and &r5 =  999 and &r4 ne 999 then c = 4;
 else	if  &r8 =  999 and &r7  = 999 and &r6 = 999  
		and &r5 =  999 and &r4  = 999 and &r3 ne 999 then c = 3;
 else	if  &r8 =  999 and &r7  = 999 and &r6 = 999  
		and &r5 =  999  and &r4  = 999 and &r3 = 999.
		and &r2 ne 999 then c = 2;
 else	c = 1;
 		end;

 /* 9 */

    	if _N_ = 9 then do; 
		if  &r9 ne 999 then c = 9;
 else   if  &r9 =  999 and &r8 ne 999 then c = 8;
 else   if  &r9 =  999 and &r8  = 999 and &r7 ne 999 then c = 7;
 else	if  &r9 =  999 and &r8  = 999 and &r7 = 999  
		and &r6 ne 999 then c = 6;
 else	if  &r9 =  999 and &r8  = 999 and &r7 = 999  
		and &r6 =  999 and &r5 ne 999 then c = 5;
 else	if  &r9 =  999 and &r8  = 999 and &r7 = 999  
		and &r6 =  999 and &r5  = 999 and &r4 ne 999 then c = 4;
 else	if  &r9 =  999 and &r8  = 999 and &r7 = 999  
		and &r6 =  999 and &r5  = 999 and &r4 = 999.
		and &r3 ne 999 then c = 3;
 else	if  &r9 =  999 and &r8  = 999 and &r7 = 999  
		and &r6 =  999 and &r5  = 999 and &r4 = 999.
		and &r3 =  999 and &r2 ne 999 then c = 2;
 else	c = 1;
 		end;

 /* 10 */

    	if _N_ = 10 then do;
		if  &r10 ne 999 then c = 10;
 else   if  &r10 =  999 and &r9 ne 999 then c = 9;
 else   if  &r10 =  999 and &r9  = 999 and &r8 ne 999  
		then c   =  8;
 else	if  &r10 =  999 and &r9  = 999 and &r8 = 999  
		and &r7 ne  999 then c = 7;
 else	if  &r10 =  999 and &r9  = 999 and &r8 = 999  
		and &r7  =  999 and &r6 ne 999 then c = 6;
 else	if &r10  =  999 and &r9  = 999 and &r8 = 999  
		and &r7 =  999 and &r6  = 999  and &r5 ne 999 
		then c = 5;
 else	if &r10 =  999 and &r9  = 999 and &r8 = 999  
		and &r7 =  999 and &r6  = 999 and &r5 = 999.
		and &r4 ne 999 then c = 4;
 else	if &r10 =  999 and &r9  = 999  and &r8 = 999  
		and &r7 =  999 and &r6  = 999  and &r5 = 999.
		and &r4 =  999 and &r3 ne 999  then c = 3;
  else	if &r10 =  999 and &r9  = 999  and &r8 = 999  
		and &r7 =  999 and &r6  = 999  and &r5 = 999.
		and &r4 =  999 and &r3  = 999  and &r2 ne 999 then c = 2;
 else	c = 1;
 		end;
run;

proc sql;
	select c into :c1-:c10 from switchover_b;
quit;

Data ranked1;
 Set ranked;
		if rank = 1  then rank = &c1.;
 else 	if rank = 2  then rank = &c2.;
 else 	if rank = 3  then rank = &c3.;
 else 	if rank = 4  then rank = &c4.;
 else 	if rank = 5  then rank = &c5.;
 else 	if rank = 6  then rank = &c6.;
 else 	if rank = 7  then rank = &c7.;
 else 	if rank = 8  then rank = &c8.;
 else 	if rank = 9  then rank = &c9.;
 else 	if rank = 10 then rank = &c10.;
 else rank = rank;
Run;

Proc sort data=ranked1; by rank; Run;
Proc sort data=temp; 	by rank; Run;

Data &in_dsn._3;
 Merge ranked1 temp;
 by rank;
Run;

proc sql; 
	select Count(Distinct Rank) into :R_CNT from &in_dsn._3;
quit;

proc rank data = &in_dsn._3 out = &in_dsn._4 groups = &R_CNT.;
	var rank;
	ranks &var.ORDEQ ;
run;

data &in_dsn._4;
 set &in_dsn._4;
 &var.ORDEQ = &var.ORDEQ +1;
run;

Proc Print data = &in_dsn._4 (obs=10);
	Var &var. 
		&var.ORD 
		&var.ODS 
		&var.ODS1 
		&var.ORDEQ 
		&var.ODSEQ 
		&var.ODSEQ1;
Run;

/*
proc sql;
	create table &in_dsn. as select a.*,
		b.&var.ORD		,
		b.&var.ODS 		,
		b.&var.ODS1 	,	
		b.&var.ORDEQ 	,
		b.&var.ODSEQ 	,
		b.&var.ODSEQ1
	from &in_dsn. a left join &in_dsn._4 b on a.mid = b.mid;
quit;
*/

* apply the rules to the validation dataset ;

proc means data = &in_dsn._4 min max maxdec=0;
	class &var.ORDEQ &var.ODSEQ &var.ODSEQ1 ;
	var  &var. ;
	ods output Summary = rules;
run;

proc sql; select count(*) into :cnt from rules; quit;

data rules2 ;
 set rules ;
 format sas_code $150. ;
 if _n_ = 1 then do;
 sas_code 
 = "if &var. < "||compress(&var._max)||" then do; "||" &var.ORDEQ ="||compress(&var.ORDEQ)||"; &var.ODSEQ ="||compress(&var.ODSEQ)||"; &var.ODSEQ1 ="||compress(&var.ODSEQ1)||"; end;" ;
 end;
 else  do;
 sas_code = "else if &var. < "||compress(&var._max)||" then do; "||" &var.ORDEQ ="||compress(&var.ORDEQ)||"; &var.ODSEQ ="||compress(&var.ODSEQ)||"; &var.ODSEQ1 ="||compress(&var.ODSEQ1)||"; end;" ; 
 end;
 if _n_ = &cnt. then do;
 sas_code = "else do; "||" &var.ORDEQ ="||compress(&var.ORDEQ)||"; &var.ODSEQ ="||compress(&var.ODSEQ)||"; &var.ODSEQ1 ="||compress(&var.ODSEQ1)||"; end;" ; 
 end;
run;

proc sql; select sas_code into :code seperated by ' ' from rules2; quit;

data &vds.;
 set &vds.;
 &code.
run;

data &dsn.;
 set &dsn.;
 &code.
run;

%end;

%Macro CAT_CLUSTERING(DSN=,RSP=,CAT=,NewVar=);
%Global &NewVar._GRP;
proc means data = &dsn. noprint nway; class &cat. ; var &rsp. ; output out = level mean = prop; run;
proc cluster data = level method = ward outtree = fortree ; freq _freq_ ; var prop ; id &cat. ; ods output clusterHistory = Cluster; run ;
proc freq data = &dsn. noprint; tables &cat.*&rsp. / chisq; output out = chi(keep = _pchi_) chisq; run;
data cutoff; if _n_ = 1 then set chi; set cluster ; chisquare = _pchi_*rsquared; degfree = numberofclusters-1; logpvalue = logsdf('CHISQ',chisquare,degfree); run;
proc plot data = cutoff ; plot logpvalue*numberofclusters / vpos = 30; run; quit;
proc sql; select NumberOfClusters into :ncl from cutoff having logpvalue = min(logpvalue); quit;
proc tree data = fortree  h = rsq nclusters = &ncl.  out = clus; id &cat.; run;
proc sort data = clus; by clusname; run; proc print data = clus; by clusname; id clusname; run;
Proc SQL; Create Table &DSN._CATS as select a.*, b.Cluster as &NewVar._GRP from &DSN.  a left join clus b on a.&Cat. = b.&Cat. ; Quit;
Title "New Clusted Version of &CAT.";
Proc Freq data = &DSN._CATS ; tables &NewVar._GRP*&RSP. / nocol nofreq nopercent;
Proc Freq data = &DSN._CATS ; tables &NewVar._GRP / nopercent nocum; Run ; Title;
data clus_code; set clus; format sas_code $75. ; if _n_ = 1 then do;
sas_code =      "IF &CAT. = '"||compress(&CAT.)||"' then  &NewVar._GRP = '"||compress(put(Cluster,5.))||"' ; " ; end;
else if _n_ > 1 then do; sas_code = "Else IF &CAT. = '"||compress(&CAT.)||"' then  &NewVar._GRP = '"||compress(put(Cluster,5.))||"' ; " ; end; run; 
title "Clus Code for Cat = &CAT and NewVar = &NewVar.";
Proc Print data = clus_code; run; title;
proc sql; select SAS_CODE into :&NewVar._GRP separated by ' ' from clus_code; quit;
%Put The sas code for createing the &NewVar._GRP is &&&NewVar._GRP. ;
%Mend CAT_CLUSTERING ; * %CAT_CLUSTERING(DSN=,RSP=,CAT=,NewVar=) ;

%CAT_CLUSTERING(DSN = &dsn., RSP=Quick_Close, CAT=SIC ,  			NewVar=IND )
%CAT_CLUSTERING(DSN = &dsn., RSP=Quick_Close, CAT=CRR ,  			NewVar=CHN )
%CAT_CLUSTERING(DSN = &dsn., RSP=Quick_Close, CAT=STATE, 			NewVar=GEO )
%CAT_CLUSTERING(DSN = &dsn., RSP=Quick_Close, CAT=Terminal_Key , 	NewVar=POS )
%CAT_CLUSTERING(DSN = &dsn., RSP=Quick_Close, CAT=PRICING_TYPE ,    NewVar=PTY )

data &dsn. ; 
 set &dsn. ; 
 &IND_GRP. &CHN_GRP. &GEO_GRP. &POS_GRP. &PTY_GRP. 
run;

data &vds.;
 set &vds.;
 &IND_GRP. &CHN_GRP. &GEO_GRP. &POS_GRP. &PTY_GRP.  
run;

%let v = IND_GRP; %let cnt = 12;
data &dsn.;
 set &dsn.;
array dummies(&cnt.) &V._1 - &V._&cnt. (&cnt.*0);  
if &V. ne . then dummies(&V.) = 1; output; if &V. ne . then dummies(&V.) = 0;
run;

data &vds.;
 set &vds.;
array dummies(&cnt.) &V._1 - &V._&cnt. (&cnt.*0);  
if &V. ne . then dummies(&V.) = 1; output; if &V. ne . then dummies(&V.) = 0;
run;


%let v = CHN_GRP; %let cnt = 10;
data &dsn.;
 set &dsn.;
array dummies(&cnt.) &V._1 - &V._&cnt. (&cnt.*0);  
if &V. ne . then dummies(&V.) = 1; output; if &V. ne . then dummies(&V.) = 0;
run;

data &vds.;
 set &vds.;
array dummies(&cnt.) &V._1 - &V._&cnt. (&cnt.*0);  
if &V. ne . then dummies(&V.) = 1; output; if &V. ne . then dummies(&V.) = 0;
run;

%let v = GEO_GRP; %let cnt = 7;
data &dsn.;
 set &dsn.;
array dummies(&cnt.) &V._1 - &V._&cnt. (&cnt.*0);  
if &V. ne . then dummies(&V.) = 1; output; if &V. ne . then dummies(&V.) = 0;
run;

data &vds.;
 set &vds.;
array dummies(&cnt.) &V._1 - &V._&cnt. (&cnt.*0);  
if &V. ne . then dummies(&V.) = 1; output; if &V. ne . then dummies(&V.) = 0;
run;

%let v = POS_GRP; %let cnt = 8;
data &dsn. ;
 set &dsn. ;
array dummies(&cnt.) &V._1 - &V._&cnt. (&cnt.*0);  
if &V. ne . then dummies(&V.) = 1; output; if &V. ne . then dummies(&V.) = 0;
run;

data &vds. ;
 set &vds. ;
array dummies(&cnt.) &V._1 - &V._&cnt. (&cnt.*0);  
if &V. ne . then dummies(&V.) = 1; output; if &V. ne . then dummies(&V.) = 0;
run;

%let v = PTY_GRP; %let cnt = 4;
data &dsn. ;
 set &dsn. ;
array dummies(&cnt.) &V._1 - &V._&cnt. (&cnt.*0);  
if &V. ne . then dummies(&V.) = 1; output; if &V. ne . then dummies(&V.) = 0;
run;

data &vds. ;
 set &vds. ;
array dummies(&cnt.) &V._1 - &V._&cnt. (&cnt.*0);  
if &V. ne . then dummies(&V.) = 1; output; if &V. ne . then dummies(&V.) = 0;
run;

proc contents data = &dsn. varnum; 	
ods output Position = VARS (where=(Type='Num' and Num>=23));
run;

%Macro PCT_TRANS (var=,dsn=,op=,filez=,FileName=);
proc rank data = &dsn groups = 100 out = out ; var &var. ; ranks bin ; run;
proc means data = out noprint nway ; class bin ; var &var. ; output out = EndPts max = max ; run ;
filename &FileName. "&op\&filez..sas" ;
data _Null_ ; file &FileName. ; set  endpts end = last;
 if _n_ = 1 then put "select;";
 if not last then do; put " when (&var. <= " max ") &filez. =" bin ";"; end;
 else if last then do; put "otherwise &filez. =" bin ";"; put "end;"; end;
run;
%mend PCT_TRANS ;

%let var_num_list =PMV PAT Biz_TiY;
%let var_cnt = 3 ;

%do x = 1 %to &var_cnt.;
%let var = %scan(&var_num_list.,&x.,' ');
%PCT_TRANS 
(	var		 =	&VAR.	,  
	filez	 = 	B_&VAR.	, 
	FileName =  BIN_&X.	,
	DSN		 =	&DSN.	, 
	op		 =	C:\Users\srseibe\Desktop\Task\Adv. Analytics\FYC - 2015-03-01\sas_code)
%end;

data &dsn. ;
 set &dsn. ; 
 %include BIN_1 ; %include BIN_2 ; %include BIN_3 ; 
run ;

data &vds. ;
 set &vds. ; 
 %include BIN_1 ; %include BIN_2 ; %include BIN_3 ; 
run ;

/*
proc sql; 
	select Variable into: var_num_list SEPARATED by ' ' from vars;
	select count(Variable) into: var_cnt from vars;
quit;
*/

%mend Feature;

%Feature

/*

options NoMPrint NoSymbolgen;
	%Feature
options MPrint Symbolgen;

proc contents data = &dsn varnum; 	
run;

*/

proc means data = &dsn n NMISS;
 var _numeric_ ;
 run;

 proc means data = &vds n NMISS;
 var _numeric_ ;
 run;

proc print data = &dsn (obs=10);
 	where PMVODSEQ = .;
run;

proc print data = &vds (obs=10);
 	where PMVODSEQ = .;
run;


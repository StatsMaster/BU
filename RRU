

/* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//*~~~~~~~~~~~ *//* ~~~~~~~~~~~ */
/* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//*~~~~~~~~~~~ *//* ~~~~~~~~~~~ */
/* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//*~~~~~~~~~~~ *//* ~~~~~~~~~~~ */
/*
																						  2013-11-19
	 ____    ____  _____  ______            _                   _______     ________  _____     
	|_   \  /   _||_   _||_   _ `.         / |_                |_   __ \   |_   __  ||_   _|    
	  |   \/   |    | |    | | `. \       `| |-' .--.            | |__) |    | |_ \_|  | |      
	  | |\  /| |    | |    | |  | |        | | / .'`\ \          |  __ /     |  _| _   | |   _  
	 _| |_\/_| |_  _| |_  _| |_.' /_______ | |,| \__. |_______  _| |  \ \_  _| |__/ | _| |__/ | 
	|_____||_____||_____||______.'|_______|\__/ '.__.'|_______||____| |___||________||________|


For MIDs Open in the period
	
*/
/* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//*~~~~~~~~~~~ *//* ~~~~~~~~~~~ */
/* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//*~~~~~~~~~~~ *//* ~~~~~~~~~~~ */
/* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//*~~~~~~~~~~~ *//* ~~~~~~~~~~~ */


/*
	Tables of Contents for Relationship Roll Up (RRU)
		#1	Pull Monthly Data - Create the base table
		#2	Remove Closed Accounts
		#3a	Build the Table of Tax ID Counts
		#3b Build the table of Bank ID Counts
		#4  Left join the tax ID counts to the base table
		#5  Create the bank ID match key on the base table
		#6  UNI QC
		#7  Seperate the base dataset into three based on the rela groups: MANAGED, TAX, OTHER
		#8  Left join the bank ID count to the OTHER table
		#9  UNI QC 
		#10 ID the MIDs Relationships and Relationship Type  
		#11 Clean Up - Delete unneeded datasets
		#12 UNI QC
		#13 Build relationship level measurements
		#14 Left join the CID bank card VOL
		#15 UNI QC
		#16 Create Small & Medium Business Identifier
		#17 Upload file to Business Development
*/


%Macro RRU_OPEN;

/* #1 Pull Monthly Data */

/* %do x = 1 %to 71; */

/* %do x = 1 %to 28; */

%do x = 1 %to 1;

/* The Current Period */
data _null_ ; 
	Call Symputx
	('Period',Upcase(Compress("'"||put(intnx('month',&Starting_Period.d,&x.),date9.)||"'"))) ; 
run;

/* The Current Period minus 11 months */
data _null_ ; 
	Call SymputX
	('Period_Minus_11',Upcase(Compress("'"||put(intnx('month',&Period.d,-11),date9.)||"'"))) ; 
run ;

/* The Current Year */
%let Curr_Year     = %sysfunc(year(&Period.D)) ;

/* The Beginning of the Current Year */
%let CBY = "01JAN&CURR_YEAR." ;
data _null_ ; 
	Call SymputX
	('Curr_Beg_Year',Upcase(Compress("'"||put(&CBY.d,date9.)||"'"))) ; 
run ;

/* The Current Period minus 12 months */
data _null_ ; 
	Call SymputX
	('Period_Minus_12',Upcase(Compress("'"||put(intnx('month',&Period.d,-12),date9.)||"'"))) ; 
run ;

/* The Last year */
%let Last_Year     = %sysfunc(year(&Period_Minus_12.D)) ;

/* The beginning of the last year */
%let LBY = "01JAN&Last_YEAR." ;

data _null_ ; 
	Call SymputX
	('Last_Beg_Year',Upcase(Compress("'"||put(&LBY.d,date9.)||"'"))) ; 
run ;

data _null_ ; 
	Call SymputX
	('Mon_Name',Upcase(substr(Compress(Put(&Period.D,monname.)),1,3))); 
run;

data _null_;
 if month(&Period.D) < 10 then 
	call symputx('Mon',compress("0"||put(month(&Period.D),4.)));
 else call symputx('Mon',put(month(&Period.D),4.));
run;

%let T_Name 	= MID_to_REL_&Curr_Year._&Mon.;

%Put 
The defined macro values are,
	Period: &period. 
	The Period year: &Curr_Year. 
	The Period month: &mon_name. 
	The Dataset name: &t_name 

	Period minus 12 months: &Period_Minus_12.
	Period minus 11 months: &Period_Minus_11.

	The Beginning of this year 01 &CBY
	The Beginning of this year 02 &Curr_Beg_Year
	The Beginning of last year 01 &LBY
	The Beginning of last year 01 &Last_Beg_Year
;

proc sql;
	connect to oracle (user = &U. password = &P. path= 'NEWDW01.WORLD');

/* #1  Base table, pulled rolling 12 activity for the period */
	create table &T_Name. as select * from connection to oracle ( select 
b.period , 
a.addressable , 
a.channel , 
a.rdc , 
c.sponsorid , 
c.assocnumber , 
c.mid , 
c.dbaname , 
c.merchstatus_ecp , 
c.date_opened , 
c.date_closed , 
nvl(c.siccode,'0000') as SICCODE , 
e.sic_description , 
e.sector_rollup , 
e.sub_rollup , 
e.naics_6 , 
e.naics_6_description , 
e.naics_5 , 
e.naics_5_description , 
e.naics_4 ,
e.naics_4_description , 
e.naics_3 , 
e.naics_3_description , 
e.naics_2 , 
e.naics_2_description , 
c.fedtaxid , 
c.fundingaba , 
c.fundingdda , 

d.group_ 						as REL_TYPE , 
d.rel_long 						as RELATIONSHIP , 

nvl(b.trancount,0)  			as BC_TRANCOUNT , 
nvl(b.netvolume,0) 				as BC_VOLUME , 
nvl(b.stm_discount,0) 		+ nvl(b.stm_surcharge,0) 	- nvl(b.pin_db_auth_income,0)
+ nvl(b.stm_authrevenue,0)	+ nvl(b.stm_ind_plan,0)
+ nvl(b.stm_data_cap,0) 	- nvl(b.tsys_intchg,0)	 	- nvl(b.assesments,0) as BC_DIA , 

nvl(b.dscv_trancount,0) 		as DSCV_TRANCOUNT , 
nvl(b.dscv_volume,0) 			as DSCV_VOLUME  , 
nvl(b.dscv_discount,0) 		- nvl(b.dscv_interchange,0)	- nvl(b.dscv_assessments,0)
 								as DSCV_DIA , 

nvl(b.pin_db_trancount,0) 		as PIN_DB_TRANCNT , 
nvl(b.pin_db_volume,0) 			as PIN_DB_VOLUME  , 
nvl(b.pin_db_discount,0) 		+ nvl(b.pin_db_auth_income,0)
- nvl(b.pin_db_interchange,0) 	- nvl(b.pin_db_assessments,0) - nvl(b.pin_db_switch_fee,0) 	
								as PIN_DB_DIA ,

nvl(b.stm_discount,0) 			+ nvl(b.stm_surcharge,0) 		- nvl(b.pin_db_auth_income,0)
+ nvl(b.stm_authrevenue,0)		+ nvl(b.stm_ind_plan,0) 		+ nvl(b.stm_data_cap,0) 	
- nvl(b.tsys_intchg,0)			- nvl(b.assesments,0) 			+ nvl(b.dscv_discount,0) 
- nvl(b.dscv_interchange,0) 	- nvl(b.dscv_assessments,0) 	+ nvl(b.pin_db_discount,0) 
+ nvl(b.pin_db_auth_income,0)	- nvl(b.pin_db_interchange,0) 	- nvl(b.pin_db_assessments,0) 
- nvl(b.pin_db_switch_fee,0) 						as MID_DIA , 
nvl(b.stm_feerevenue,0) 		- nvl(b.pos_fee,0) 	as OTHER_REV , 

nvl(b.stm_discount,0) 			+ nvl(b.stm_surcharge,0) 		- nvl(b.pin_db_auth_income,0)
+ nvl(b.stm_authrevenue,0)		+ nvl(b.stm_ind_plan,0)			+ nvl(b.stm_data_cap,0)
- nvl(b.tsys_intchg,0)			- nvl(b.assesments,0) 			+ nvl(b.dscv_discount,0) 
- nvl(b.dscv_interchange,0)		- nvl(b.dscv_assessments,0)		+ nvl(b.pin_db_discount,0) 
+ nvl(b.pin_db_auth_income,0) 	- nvl(b.pin_db_interchange,0) 	- nvl(b.pin_db_assessments,0) -
 nvl(b.pin_db_switch_fee,0)		+ nvl(b.stm_feerevenue,0) 		- nvl(b.pos_fee,0) 
as MID_DIAO

from 	bsnsdevl.mid_owner 				a , 
		browser.roll_mti 				b , 
		browser.merch_demo_info_master 	c , 
		bsnsdevl.mid_relationship 		d , 
		bsnsdevl.naics_lu 				e 
	
where 	a.mid = b.mid
and 	a.mid = c.mid
and 	a.mid = d.mid (+)
and 	nvl(c.siccode,'0000') = e.siccode (+)
and 	c.sponsorid < '0026'
and 	c.sponsorid<> '0006'
and 	nvl(c.siccode,'9999') not in ('6010','6011')
and 	b.period = &Period. );

/* MID Residual RTM */

create table MID_R_RTM as select * from connection to oracle (select 
		MID, sum(nvl(amount,0)) as MID_R 
		from browser.mth_mid_residual where period
		between &Period_Minus_11. and &Period. group by MID);


/* MID Current YTD ( VOL, TRN, DIA, O, DIAO ) */

create table CURR_YTD as select * from connection to oracle (select		
		mid, 			 sum(nvl(a.trancount,0)) as CURR_YTD_TRN ,
					     sum(nvl(a.netvolume,0)) as CURR_YTD_VOL ,
	   	sum(nvl(a.stm_discount,	 	0) + nvl(a.stm_surcharge,		0) 		
	 	+ 	nvl(a.stm_authrevenue, 	0) + nvl(a.stm_ind_plan,		0) 	+ nvl(a.stm_data_cap,0) 		
	 	- 	nvl(a.tsys_intchg,	 	0) - nvl(a.assesments,		 	0) 			
	 	+ 	nvl(a.dscv_discount,	0) - nvl(a.dscv_interchange,	0) 	- nvl(a.dscv_assessments,0) 
	 	+ 	nvl(a.pin_db_discount, 	0) - nvl(a.pin_db_interchange, 	0)	- nvl(a.pin_db_assessments,	0) 	- nvl(a.pin_db_switch_fee,0))
								as CURR_YTD_DIA ,
		sum(nvl(a.stm_feerevenue,0) - nvl(a.pos_fee,0)) 
								as CURR_YTD_O   ,
		sum(nvl(a.stm_discount,0) 		+ nvl(a.stm_surcharge,0) 		- nvl(a.pin_db_auth_income,0)
		+ nvl(a.stm_authrevenue,0)		+ nvl(a.stm_ind_plan,0)			+ nvl(a.stm_data_cap,0)
		- nvl(a.tsys_intchg,0)			- nvl(a.assesments,0) 			+ nvl(a.dscv_discount,0) 
		- nvl(a.dscv_interchange,0)		- nvl(a.dscv_assessments,0)		+ nvl(a.pin_db_discount,0) 
		+ nvl(a.pin_db_auth_income,0) 	- nvl(a.pin_db_interchange,0) 	- nvl(a.pin_db_assessments,0) -
 		  nvl(a.pin_db_switch_fee,0)    + nvl(a.stm_feerevenue,0) 		- nvl(a.pos_fee,0))
								as CURR_YTD_DIAO
		from browser.merch_tran_info a 
		where period between &Curr_Beg_Year. and &Period.    
		group by MID );

/* MID Last YTD ( VOL, TRN, DIA, O, DIAO ) */

create table LAST_YTD as select * from connection to oracle (select 
		mid, sum(nvl(a.trancount,0)) as LAST_YTD_TRN ,
					 sum(nvl(a.netvolume,0)) as LAST_YTD_VOL ,
	   	sum(nvl(a.stm_discount,	 	0) + nvl(a.stm_surcharge,		0) 		
	 	+ 	nvl(a.stm_authrevenue, 	0) + nvl(a.stm_ind_plan,		0) 	+ nvl(a.stm_data_cap,0) 		
	 	- 	nvl(a.tsys_intchg,	 	0) - nvl(a.assesments,		 	0) 			
	 	+ 	nvl(a.dscv_discount,	0) - nvl(a.dscv_interchange,	0) 	- nvl(a.dscv_assessments,0) 
	 	+ 	nvl(a.pin_db_discount, 	0) - nvl(a.pin_db_interchange, 	0)	- nvl(a.pin_db_assessments,	0) 	- nvl(a.pin_db_switch_fee,0))
											as LAST_YTD_DIA ,
		sum(nvl(a.stm_feerevenue,0) - nvl(a.pos_fee,0)) 
											as LAST_YTD_O   ,
	  sum(nvl(a.stm_discount,0) 		+ nvl(a.stm_surcharge,0) 		- nvl(a.pin_db_auth_income,0)
		+ nvl(a.stm_authrevenue,0)		+ nvl(a.stm_ind_plan,0)			+ nvl(a.stm_data_cap,0)
		- nvl(a.tsys_intchg,0)			- nvl(a.assesments,0) 			+ nvl(a.dscv_discount,0) 
		- nvl(a.dscv_interchange,0)		- nvl(a.dscv_assessments,0)		+ nvl(a.pin_db_discount,0) 
		+ nvl(a.pin_db_auth_income,0) 	- nvl(a.pin_db_interchange,0) 	- nvl(a.pin_db_assessments,0) -
 		  nvl(a.pin_db_switch_fee,0)    + nvl(a.stm_feerevenue,0) 		- nvl(a.pos_fee,0))
											as LAST_YTD_DIAO
		from browser.merch_tran_info a
		where period between &Last_Beg_Year. and &Period_Minus_12.    
		group by MID);

/* VAS --{ EGC , ECS , DEBIT , DCC }-- */

create table EGC as select * from connection to oracle (
	select Distinct MID, 'Y' as EGC from aep.mersum_mersum where hasfrequency in ('1','Y'));

create table ECS as select *  from connection to oracle (
	select Distinct MID, 'Y' as ECS from aep.mersum_mersum where hasecc = 'Y');

create table DBT as select * from connection to oracle (
	select Distinct MID, 'Y' as DEBIT from dw.merchantcard where cardtypecode = 'DB' and captureind = '1');

create table DCC as select * from connection to oracle (
	select Distinct MID, 'Y' as DCC from browser.merch_demo_info_master where has_dcc = 'Y');
 
disconnect from oracle;

	create table &T_Name. as select a.*, 	

	coalesce(b.MID_R,0) as MID_R ,

	coalesce(c.Curr_YTD_TRN  , 0) as Curr_YTD_TRN  ,
	coalesce(c.Curr_YTD_VOL  , 0) as Curr_YTD_VOL  ,
	coalesce(c.Curr_YTD_DIA  , 0) as Curr_YTD_DIA  ,
	coalesce(c.Curr_YTD_O    , 0) as Curr_YTD_O    ,
	coalesce(c.Curr_YTD_DIAO , 0) as Curr_YTD_DIAO ,

	coalesce(d.Last_YTD_TRN  , 0) as Last_YTD_TRN  ,
	coalesce(d.Last_YTD_VOL  , 0) as Last_YTD_VOL  ,
	coalesce(d.Last_YTD_DIA  , 0) as Last_YTD_DIA  ,
	coalesce(d.Last_YTD_O    , 0) as Last_YTD_O    ,
	coalesce(d.Last_YTD_DIAO , 0) as Last_YTD_DIAO ,

	coalesceC(e.EGC,  'N')		  as EGC   ,	
	coalesceC(f.ECS,  'N')		  as ECS   ,
	coalesceC(g.DEBIT,'N')		  as DEBIT ,
	coalesceC(h.DCC,  'N')		  as DCC

	from 		&T_Name. 	a 
	left join	MID_R_RTM	b on a.mid = b.mid
	left join	CURR_YTD	c on a.mid = c.mid
	left join	LAST_YTD	d on a.mid = d.mid 
	left join 	EGC			e on a.mid = e.mid 
	left join 	ECS			f on a.mid = f.mid 
	left join	DBT			g on a.mid = g.mid 
	left join	DCC			h on a.mid = h.mid ;

/* #2  Indentify and remove MIDs who were not open during the period */

	create table Closed_MIDs as select Distinct MID, 1 as Closed
	from &T_Name. where datepart(date_closed) < &Period.D and datepart(date_closed) is not null;

	create table &T_Name. as select a.*, b.Closed 
	from &T_Name. a left join Closed_MIDs b on a.mid = b.mid;

	drop table Closed_MIDs;

Quit;

data &T_Name. ;
 set &T_Name. ;
 if Closed then delete; Drop Closed;
Run;

Proc Datasets library = Work NoList NoDetails;
	modify &T_Name.;
	index create MID ;
run;

proc sql;

/* #3a  Build the table of tax id counts */

	create table MULTI_TAX_ID as select  fedtaxid, Count(*) as TAX_CNT 
	from 	&T_Name.
	where 	coalesce(fedtaxid,'0') not in ('0', '999999999', '000000000','0000000000')  
	and		REL_TYPE not in ('AIRLN', 'HOSP', 'RM', 'HCARE','STRAT') 
Group by fedtaxid ;

/* #3b  Build the table of bank id counts */

	create table MULTI_DDA_ID as select compress(fundingaba||fundingdda) as BNK_ID,
 	Count(*) as BNK_CNT from &T_Name.
	where 	coalesce(compress(fundingaba||fundingdda),'0') ne '0' 
	and		REL_TYPE not in ('AIRLN', 'HOSP', 'RM', 'HCARE','STRAT') 
	Group by compress(fundingaba||fundingdda) ;

/* #4  left join the tax counts to the base table */

	create table &T_Name. as select a.*, b.TAX_CNT 
	from &T_Name. a left join MULTI_TAX_ID b on a.fedtaxid = b.fedtaxid ;

quit;

proc sql; drop table MULTI_TAX_ID; quit;

/* #5  Create the bank ID match key on the base table */

data &T_Name.;
 set &T_Name.;
 BNK_ID = compress(fundingaba||fundingdda);
run;

/* #6  UNI QC */

proc sort data = &T_Name. NoDupKey; by mid; run;

/* 	#7  Seperate the MIDs into three groups 
	first, Managed relationships
	second, MIDs with tax counts great than one
	last, the remaining MIDS */

data 	SMB_ID_Managed 
		SMB_ID_FEDTAXID
		SMB_ID_OTHER;
set &T_Name.;
		if Rel_Type in ('AIRLN', 'HOSP', 'RM', 'HCARE','STRAT')  then Output SMB_ID_Managed ;
else	if TAX_CNT	> 1 then output SMB_ID_FEDTAXID ;
else output SMB_ID_OTHER;
run;

/* #8  For the remaining MIDs left join the bank count */

data SMB_ID_OTHER_1 SMB_ID_OTHER_2 
	 SMB_ID_OTHER_3 SMB_ID_OTHER_4
	 SMB_ID_OTHER_5 SMB_ID_OTHER_6
     SMB_ID_OTHER_7 SMB_ID_OTHER_8
	 SMB_ID_OTHER_9 SMB_ID_OTHER_10 ;
 set SMB_ID_OTHER ;
 random = ranuni(20120214);
      if random <= 0.10 then output SMB_ID_OTHER_1 ;
 else if random <= 0.20 then output SMB_ID_OTHER_2 ;
 else if random <= 0.30 then output SMB_ID_OTHER_3 ;
 else if random <= 0.40 then output SMB_ID_OTHER_4 ;
 else if random <= 0.50 then output SMB_ID_OTHER_5 ;
 else if random <= 0.60 then output SMB_ID_OTHER_6 ;
 else if random <= 0.70 then output SMB_ID_OTHER_7 ;
 else if random <= 0.80 then output SMB_ID_OTHER_8 ;
 else if random <= 0.90 then output SMB_ID_OTHER_9 ;
 else if random <= 1.00 then output SMB_ID_OTHER_10 ;
 drop random;
run;

%macro mini_loop;
%do j = 1 %to 10;
proc sql;
	create table BNK_ID_LIST as select distinct BNK_ID, BNK_CNT
	from MULTI_DDA_ID where BNK_ID in (select distinct bnk_id from SMB_ID_OTHER_&j.);

	create table SMB_ID_OTHER_&j. as select a.*, c.BNK_CNT  
	from SMB_ID_OTHER_&j. a  left join BNK_ID_LIST c on a.BNK_ID = c.BNK_ID;
quit;
%end;
proc sql; drop table BNK_ID_LIST; quit;
%mend;
%mini_loop

proc sql; drop table MULTI_DDA_ID; quit;

data SMB_ID_OTHER;
 set SMB_ID_OTHER_1 SMB_ID_OTHER_2 
	 SMB_ID_OTHER_3 SMB_ID_OTHER_4
	 SMB_ID_OTHER_5 SMB_ID_OTHER_6
     SMB_ID_OTHER_7 SMB_ID_OTHER_8
	 SMB_ID_OTHER_9 SMB_ID_OTHER_10;
run;

proc datasets lib = work NoDetails NoList; 
	Delete 
     SMB_ID_OTHER_1 SMB_ID_OTHER_2 
	 SMB_ID_OTHER_3 SMB_ID_OTHER_4
	 SMB_ID_OTHER_5 SMB_ID_OTHER_6
     SMB_ID_OTHER_7 SMB_ID_OTHER_8
	 SMB_ID_OTHER_9 SMB_ID_OTHER_10; 
quit;

/* #9  UNI QC */

proc sort data = SMB_ID_OTHER NoDupKey; by mid; run;

/* 
	#10 ID the MIDs Relationship and Relationship Type  

	a.) Stack the three datasets, managed, tax, other 
	b.) If the MID has a previously defined relationship, keep that rel info the same 
	c.) If the MID was found to have a tax ID greater than 1, use the fed tax ID as their relationship information
	d.) If the MID was found to have a bank ID greater than 1, use the aba/dda as their relationship information
	c.) last, if no info was found, the customer is assumed to be represented by a solo account
*/

data &T_Name. ;
 set SMB_ID_Managed 
	 SMB_ID_FEDTAXID
	 SMB_ID_OTHER ;

	 	if Rel_Type in ('AIRLN', 'HOSP', 'RM', 'HCARE','STRAT')  then
							do; rel_type =  rel_type; 	Relationship = Relationship; 					 end;   
 else	if TAX_CNT > 1 then do; rel_type = 'FEDTAXID'; 	Relationship = fedtaxid;						 end;
 else 	if BNK_CNT > 1 and fundingaba ne '' and fundingdda ne ''
					   then do; rel_type = 'ABA_DDA';  	Relationship = compress(fundingaba||fundingdda); end;
 else					    do; rel_type = 'MID'; 		Relationship = MID; 							 end;
 		if REL_TYPE in ('AIRLN', 'HOSP', 'RM', 'HCARE','STRAT')  then Managed = 'Y'; else Managed ='N';
		if sponsorid = '0019' then MID_R  = 0;
		if MID_R = . then MID_R = 0;
Run;

/* #11  Clean Up */

proc datasets lib = work NoDetails NoList; 
	Delete SMB_ID_Managed SMB_ID_FEDTAXID SMB_ID_OTHER ; 
quit;

/* #12  UNI QC */

proc sort data = &T_Name. NoDupKey; by mid; run;

proc sql;

/* #13  Build Relationship Level Measurements */

	create table Rela_BC as select 
		Relationship ,
		Count(Distinct MID)				as Rel_MIDCNT ,	
		sum(coalesce(bc_trancount,0)) 	as Rel_BC_TRANCOUNT ,
		sum(coalesce(bc_volume,0)) 		as Rel_BC_VOL , 
		sum(coalesce(bc_dia,0)) 		as Rel_BC_DIA ,
		sum(coalesce(mid_dia,0)) 		as Rel_DIA ,
		sum(coalesce(mid_diao,0)) 		as Rel_DIAO ,
		sum(coalesce(mid_R,0)) 			as Rel_R
	from &T_Name.  
	group by Relationship;
quit;

/* Sort the data by BC volume within relationships */

proc sort data = &T_Name. Out = Top;
	by Relationship descending bc_volume ;
Run;

/* Keep only the first record, (highest VOL), for each relationship */

proc sort data = Top NoDupKey;
	by Relationship;
run;

data Top;
 set Top;
 Rel_Top_MID = 'Y';
run;

/* #14  Left join the CID bank card VOL */

proc sql;
	create table &T_Name. as select a.* , 
		b.Rel_MIDCNT ,	
		b.Rel_BC_TRANCOUNT ,
		b.Rel_BC_VOL , 
		b.Rel_BC_DIA ,
		b.Rel_DIA ,
		b.Rel_DIAO , 
		b.Rel_R , 
		c.Rel_Top_MID
	from &T_Name. 		a 
	left join Rela_BC 	b on a.Relationship = b.Relationship
	left join Top		c on a.mid = c.mid;
quit;

proc datasets lib = work NoDetails NoList; 
	Delete rela_bc Top ; 
quit;

/* #15  UNI QC */

proc sort data = &T_Name. NoDupKey; by mid; run;

/* 
	#16  
		Small & Medium Business Identifier
	Each MID with a CID RTM BC VOL < $5M is SMB

		Top MID Identifier
	The MID with the biggest amount of bank card VOL
*/

data &T_Name.;
 set &T_Name.;
 if Rel_Top_MID ne 'Y' then Rel_Top_MID = 'N';
 if rel_bc_vol < 5000000 then SMB = 1; else SMB = 0;
 if Tax_Cnt = .  then Tax_Cnt = 0;
 if Bnk_Cnt = .  then Bnk_Cnt = 0;
run;

/* #17  Upload file to Business Development */

proc sql;
	drop   table 	bsnsdevl.&T_Name. ;
	create table 	bsnsdevl.&T_Name. like &T_Name. ;
	insert into  	bsnsdevl.&T_Name. select * from &T_Name. ;
	drop   table	&T_Name. ;
quit;

%end;

/* 
  __  __             _   _       _          __  __             _   _        _____ _                            
 |  \/  |           | | | |     | |        |  \/  |           | | | |      / ____| |                           
 | \  / | ___  _ __ | |_| |__   | |_ ___   | \  / | ___  _ __ | |_| |__   | |    | |__   __ _ _ __   __ _  ___ 
 | |\/| |/ _ \| '_ \| __| '_ \  | __/ _ \  | |\/| |/ _ \| '_ \| __| '_ \  | |    | '_ \ / _` | '_ \ / _` |/ _ \
 | |  | | (_) | | | | |_| | | | | || (_) | | |  | | (_) | | | | |_| | | | | |____| | | | (_| | | | | (_| |  __/
 |_|  |_|\___/|_| |_|\__|_| |_|  \__\___/  |_|  |_|\___/|_| |_|\__|_| |_|  \_____|_| |_|\__,_|_| |_|\__, |\___|
                                                                                                     __/ |     
                                                                                                    |___/      

  _____                  _____ _____ _____  _       __  __ _____ _____  _     
 |_   _|                / ____|_   _|  __ \( )     |  \/  |_   _|  __ \( )    
   | |  _ __     __ _  | |      | | | |  | |/ ___  | \  / | | | | |  | |/ ___ 
   | | | '_ \   / _` | | |      | | | |  | | / __| | |\/| | | | | |  | | / __|
  _| |_| | | | | (_| | | |____ _| |_| |__| | \__ \ | |  | |_| |_| |__| | \__ \
 |_____|_| |_|  \__,_|  \_____|_____|_____/  |___/ |_|  |_|_____|_____/  |___/
                                                                              
                                                                              
*/

proc sql;
	connect to oracle 
	(user=&U. password=&P. path='NEWDW01.WORLD');
	create table Full_MID_List as select * 
	from connection to oracle (select Distinct MID 
	from browser.merch_demo_info_master);
	disconnect from oracle;

	select compress("MTR"||trim(put(count(*),5.))) into :Last_DS
	from   dictionary.tables
	where  libname = 'BSNSDEVL' 
	and    memname like 'MID_TO_REL________' ;

	select compress(trim(put(count(*),5.))) into :DS_Count
	from   dictionary.tables
	where  libname = 'BSNSDEVL' 
	and    memname like 'MID_TO_REL________' ;

	select compress(memname) into :MTR1-:&Last_DS.
	from   dictionary.tables
	where  libname = 'BSNSDEVL' 
	and    memname like 'MID_TO_REL________' 
	order by memname descending;
quit ;


%do s = 1 %to 3;
%if &s. < 10 %then %do; %let var_name = 0&s.; %end;
%else %do; %let var_name = &s.; %end;
proc sql;
	create table Full_MID_List as select a.* ,
	b.Relationship	as REL_&var_name. , 
	b.Rel_Type 		as RTY_&var_name. ,
	b.Rel_MIDCNT	as RMC_&var_name. 
	From      Full_MID_List 	a
	left join bsnsdevl.&&MTR&s. b on a.mid = b.mid ;
Quit;
%end;

data Full_MID_List ;
 retain ID ID_Type Key ; 
 format Key $210. ID_Type $4. ID $36. ; 
 set Full_MID_List ;
run ;

%do r = 1 %to 3;
%if &r. < 10 %then %do; %let v_name = 0&r.; %end;
%else %do; %let v_name = &r.; %end;
data Full_MID_List ;
 set Full_MID_List ;
 Key = compress(Key||RTY_&v_name.);
run ;
%end;

%let RM_in_list =  'AIRLN', 'HOSP', 'RM', 'HCARE';

data Full_MID_List ;
 set Full_MID_List ;
 /* if key = '' then delete ; */
 		if index(key,'RM')
		or index(key,'HCARE')
		or index(key,'STRAT') 
		or index(key,'AIRLN')
		or index(key,'HOSP')       then ID_Type = 'MGT';
 else	if index(key,'FEDTAXID')   then ID_Type = 'TAX';
 else	if index(key,'ABA_DDA')    then ID_Type = 'BNK';
 else	if index(key,'MID') 	   then ID_Type = 'MID';
 else							   	    ID_Type = 'ERR';

 if  ID_Type = 'ERR' then delete;

 /* How many MID have been IDed with different methods in different periods? */

 if ID_Type = 'MGT' then do;
	 	if RTY_01 in (&RM_in_list.) then ID =  Rel_01 ;
 else	if RTY_02 in (&RM_in_list.) then ID =  Rel_02 ;
 else	if RTY_03 in (&RM_in_list.) then ID =  Rel_03 ;
 end;

   else if ID_Type = 'MID' then do;
	 	if RTY_01 = 'MID' then ID =  Rel_01 ;
 else	if RTY_02 = 'MID' then ID =  Rel_02 ;
 else	if RTY_03 = 'MID' then ID =  Rel_03 ;
 End;

   else if ID_Type = 'TAX' then do;
	 	if RTY_01 = "FEDTAXID" then ID =  Rel_01 ;
 else	if RTY_02 = "FEDTAXID" then ID =  Rel_02 ;
 else	if RTY_03 = "FEDTAXID" then ID =  Rel_03 ;
 End;

   else if ID_Type = 'BNK' then do;
	 	if RTY_01 = "ABA_DDA" then ID =  Rel_01 ;
 else	if RTY_02 = "ABA_DDA" then ID =  Rel_02 ;
 else	if RTY_03 = "ABA_DDA" then ID =  Rel_03 ;
 End;

 if index(key,'FEDTAXID') and index(key,'ABA_DDA')  then Quirk_ID = 1; else Quirk_ID = 0;

run ;

Proc sql;
	create table MID_CNT_by_ID as select
	ID ,
	max(RMC_01) as RMC_01 ,
	max(RMC_02) as RMC_02 ,
	max(RMC_03) as RMC_03 
	from Full_MID_List group by ID ;
quit;

data MID_CNT_by_ID ;
 set MID_CNT_by_ID ;
 RMC_Diff = RMC_01 - RMC_02  ;
 RMC_PCH  = (RMC_01 - RMC_02)/RMC_02 ;
		if RMC_02 > 0 and RMC_01  = . then CAS = '05 Cold' ;
 else	if RMC_02 = . and RMC_01  = . then CAS = 'Exclude' ;
 else	if RMC_02 =       RMC_01      then CAS = '01 Same' ;
 else	if RMC_02 = . and RMC_01  > 0 then CAS = '02 New ' ;
 else	if RMC_02 > 0 and RMC_PCH > 0 then CAS = '03 Plus' ;
 else	if RMC_02 > 0 and RMC_PCH < 0 then CAS = '04 Less' ;
run ;

proc sort data = MID_CNT_by_ID ; by CAS RMC_01 ; run;

proc sql;
	create table MID_List_v2 as select a.*, b.RMC_02 as REL_MIDCNT_LST_MTH, b.CAS as REL_MID_Alert_GRP
	from Full_MID_List a left join MID_CNT_by_ID b on a.ID = b.ID;
quit;

proc sql;
	connect to oracle 
	(user=&U. password=&P. path='NEWDW01.WORLD');
	create table Current_Month as select * 
	from connection to oracle (select *
	from BSNSDEVL.&T_Name.);
	disconnect from oracle;

	create table Current_Month as select a.*, 
		b.REL_MIDCNT_LST_MTH, 
		b.REL_MID_Alert_GRP
	from Current_Month a left join MID_List_v2 b on a.mid = b.mid;
Quit;

proc sort data = Current_Month NoDupKey; By MID; run;

proc sql;
	drop   table 	bsnsdevl.&T_Name. ;
	create table 	bsnsdevl.&T_Name. like Current_Month ;
	insert into  	bsnsdevl.&T_Name. select * from Current_Month ;
	drop   table	Current_Month ;
quit;

%mend RRU_OPEN;



/* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//*~~~~~~~~~~~ *//* ~~~~~~~~~~~ */
/* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//*~~~~~~~~~~~ *//* ~~~~~~~~~~~ */
/* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//*~~~~~~~~~~~ *//* ~~~~~~~~~~~ */
/*
																						  2013-11-19
	 ____    ____  _____  ______            _                   _______     ________  _____     
	|_   \  /   _||_   _||_   _ `.         / |_                |_   __ \   |_   __  ||_   _|    
	  |   \/   |    | |    | | `. \       `| |-' .--.            | |__) |    | |_ \_|  | |      
	  | |\  /| |    | |    | |  | |        | | / .'`\ \          |  __ /     |  _| _   | |   _  
	 _| |_\/_| |_  _| |_  _| |_.' /_______ | |,| \__. |_______  _| |  \ \_  _| |__/ | _| |__/ | 
	|_____||_____||_____||______.'|_______|\__/ '.__.'|_______||____| |___||________||________|

For MIDs regardless of open status
	
*/
/* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//*~~~~~~~~~~~ *//* ~~~~~~~~~~~ */
/* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//*~~~~~~~~~~~ *//* ~~~~~~~~~~~ */
/* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//* ~~~~~~~~~~~ *//*~~~~~~~~~~~ *//* ~~~~~~~~~~~ */


/*
	Tables of Contents for Relationship Roll Up (RRU)
		#1	Pull Monthly Data - Create the base table
		#2	Remove Closed Accounts
		#3a	Build the Table of Tax ID Counts
		#3b Build the table of Bank ID Counts
		#4  Left join the tax ID counts to the base table
		#5  Create the bank ID match key on the base table
		#6  UNI QC
		#7  Seperate the base dataset into three based on the rela groups: MANAGED, TAX, OTHER
		#8  Left join the bank ID count to the OTHER table
		#9  UNI QC 
		#10 ID the MIDs Relationships and Relationship Type  
		#11 Clean Up - Delete unneeded datasets
		#12 UNI QC
		#13 Build relationship level measurements
		#14 Left join the CID bank card VOL
		#15 UNI QC
		#16 Create Small & Medium Business Identifier
		#17 Upload file to Business Development
*/


%Macro RRU_ALL;


/* #1 Pull Monthly Data */

/* %do x = 1 %to 71; */

/* %do x = 1 %to 28; */

%do x = 1 %to 1;


/* The Current Period */


data _null_ ; 
	Call Symputx
	('Period',Upcase(Compress("'"||put(intnx('month',&Starting_Period.d,&x.),date9.)||"'"))) ; 
run;


/* The Current Period minus 11 months */


data _null_ ; 
	Call SymputX
	('Period_Minus_11',Upcase(Compress("'"||put(intnx('month',&Period.d,-11),date9.)||"'"))) ; 
run ;


/* The Current Year */


%let Curr_Year     = %sysfunc(year(&Period.D)) ;


/* The Beginning of the Current Year */


%let CBY = "01JAN&CURR_YEAR." ;
data _null_ ; 
	Call SymputX
	('Curr_Beg_Year',Upcase(Compress("'"||put(&CBY.d,date9.)||"'"))) ; 
run ;


/* The Current Period minus 12 months */


data _null_ ; 
	Call SymputX
	('Period_Minus_12',Upcase(Compress("'"||put(intnx('month',&Period.d,-12),date9.)||"'"))) ; 
run ;


/* The Last year */


%let Last_Year     = %sysfunc(year(&Period_Minus_12.D)) ;


/* The beginning of the last year */


%let LBY = "01JAN&Last_YEAR." ;

data _null_ ; 
	Call SymputX
	('Last_Beg_Year',Upcase(Compress("'"||put(&LBY.d,date9.)||"'"))) ; 
run ;

data _null_ ; 
	Call SymputX
	('Mon_Name',Upcase(substr(Compress(Put(&Period.D,monname.)),1,3))); 
run;

data _null_;
 if month(&Period.D) < 10 then 
	call symputx('Mon',compress("0"||put(month(&Period.D),4.)));
 else call symputx('Mon',put(month(&Period.D),4.));
run;

%let T_Name 	= MID_to_REL_ALL_&Curr_Year._&Mon.;

%Put 
The defined macro values are,
	Period: &period. 
	The Period year: &Curr_Year. 
	The Period month: &mon_name. 
	The Dataset name: &t_name 

	Period minus 12 months: &Period_Minus_12.
	Period minus 11 months: &Period_Minus_11.

	The Beginning of this year 01 &CBY
	The Beginning of this year 02 &Curr_Beg_Year
	The Beginning of last year 01 &LBY
	The Beginning of last year 01 &Last_Beg_Year
;

proc sql;
	connect to oracle (user = &U. password = &P. path= 'NEWDW01.WORLD');


/* #1  Base table, pulled rolling 12 activity for the period */


	create table &T_Name. as select * from connection to oracle ( select 
b.period , 
a.addressable , 
a.channel , 
a.rdc , 
c.sponsorid , 
c.assocnumber , 
c.mid , 
c.dbaname , 
c.merchstatus_ecp , 
c.date_opened , 
c.date_closed , 
nvl(c.siccode,'0000') as SICCODE , 
e.sic_description , 
e.sector_rollup , 
e.sub_rollup , 
e.naics_6 , 
e.naics_6_description , 
e.naics_5 , 
e.naics_5_description , 
e.naics_4 ,
e.naics_4_description , 
e.naics_3 , 
e.naics_3_description , 
e.naics_2 , 
e.naics_2_description , 
c.fedtaxid , 
c.fundingaba , 
c.fundingdda , 

d.group_ 						as REL_TYPE , 
d.rel_long 						as RELATIONSHIP , 

nvl(b.trancount,0)  			as BC_TRANCOUNT , 
nvl(b.netvolume,0) 				as BC_VOLUME , 
nvl(b.stm_discount,0) 		+ nvl(b.stm_surcharge,0) 	- nvl(b.pin_db_auth_income,0)
+ nvl(b.stm_authrevenue,0)	+ nvl(b.stm_ind_plan,0)
+ nvl(b.stm_data_cap,0) 	- nvl(b.tsys_intchg,0)	 	- nvl(b.assesments,0) as BC_DIA , 

nvl(b.dscv_trancount,0) 		as DSCV_TRANCOUNT , 
nvl(b.dscv_volume,0) 			as DSCV_VOLUME  , 
nvl(b.dscv_discount,0) 		- nvl(b.dscv_interchange,0)	- nvl(b.dscv_assessments,0)
 								as DSCV_DIA , 

nvl(b.pin_db_trancount,0) 		as PIN_DB_TRANCNT , 
nvl(b.pin_db_volume,0) 			as PIN_DB_VOLUME  , 
nvl(b.pin_db_discount,0) 		+ nvl(b.pin_db_auth_income,0)
- nvl(b.pin_db_interchange,0) 	- nvl(b.pin_db_assessments,0) - nvl(b.pin_db_switch_fee,0) 	
								as PIN_DB_DIA ,

nvl(b.stm_discount,0) 			+ nvl(b.stm_surcharge,0) 		- nvl(b.pin_db_auth_income,0)
+ nvl(b.stm_authrevenue,0)		+ nvl(b.stm_ind_plan,0) 		+ nvl(b.stm_data_cap,0) 	
- nvl(b.tsys_intchg,0)			- nvl(b.assesments,0) 			+ nvl(b.dscv_discount,0) 
- nvl(b.dscv_interchange,0) 	- nvl(b.dscv_assessments,0) 	+ nvl(b.pin_db_discount,0) 
+ nvl(b.pin_db_auth_income,0)	- nvl(b.pin_db_interchange,0) 	- nvl(b.pin_db_assessments,0) 
- nvl(b.pin_db_switch_fee,0) 						as MID_DIA , 
nvl(b.stm_feerevenue,0) 		- nvl(b.pos_fee,0) 	as OTHER_REV , 

nvl(b.stm_discount,0) 			+ nvl(b.stm_surcharge,0) 		- nvl(b.pin_db_auth_income,0)
+ nvl(b.stm_authrevenue,0)		+ nvl(b.stm_ind_plan,0)			+ nvl(b.stm_data_cap,0)
- nvl(b.tsys_intchg,0)			- nvl(b.assesments,0) 			+ nvl(b.dscv_discount,0) 
- nvl(b.dscv_interchange,0)		- nvl(b.dscv_assessments,0)		+ nvl(b.pin_db_discount,0) 
+ nvl(b.pin_db_auth_income,0) 	- nvl(b.pin_db_interchange,0) 	- nvl(b.pin_db_assessments,0) -
 nvl(b.pin_db_switch_fee,0)		+ nvl(b.stm_feerevenue,0) 		- nvl(b.pos_fee,0) 
as MID_DIAO

from 	bsnsdevl.mid_owner 				a , 
		browser.roll_mti 				b , 
		browser.merch_demo_info_master 	c , 
		bsnsdevl.mid_relationship 		d , 
		bsnsdevl.naics_lu 				e 
	
where 	a.mid = b.mid
and 	a.mid = c.mid
and 	a.mid = d.mid (+)
and 	nvl(c.siccode,'0000') = e.siccode (+)
and 	c.sponsorid < '0026'
and 	c.sponsorid<>'0006'
and 	nvl(c.siccode,'9999') not in ('6010','6011')
and 	b.period = &Period. );


/* MID Residual RTM */


create table MID_R_RTM as select * from connection to oracle (select 
		MID, sum(nvl(amount,0)) as MID_R 
		from browser.mth_mid_residual where period
		between &Period_Minus_11. and &Period. group by MID);


/* MID Current YTD ( VOL, TRN, DIA, O, DIAO ) */


create table CURR_YTD as select * from connection to oracle (select		
		mid, 			 sum(nvl(a.trancount,0)) as CURR_YTD_TRN ,
					     sum(nvl(a.netvolume,0)) as CURR_YTD_VOL ,
	   	sum(nvl(a.stm_discount,	 	0) + nvl(a.stm_surcharge,		0) 		
	 	+ 	nvl(a.stm_authrevenue, 	0) + nvl(a.stm_ind_plan,		0) 	+ nvl(a.stm_data_cap,0) 		
	 	- 	nvl(a.tsys_intchg,	 	0) - nvl(a.assesments,		 	0) 			
	 	+ 	nvl(a.dscv_discount,	0) - nvl(a.dscv_interchange,	0) 	- nvl(a.dscv_assessments,0) 
	 	+ 	nvl(a.pin_db_discount, 	0) - nvl(a.pin_db_interchange, 	0)	- nvl(a.pin_db_assessments,	0) 	- nvl(a.pin_db_switch_fee,0))
								as CURR_YTD_DIA ,
		sum(nvl(a.stm_feerevenue,0) - nvl(a.pos_fee,0)) 
								as CURR_YTD_O   ,
		sum(nvl(a.stm_discount,0) 		+ nvl(a.stm_surcharge,0) 		- nvl(a.pin_db_auth_income,0)
		+ nvl(a.stm_authrevenue,0)		+ nvl(a.stm_ind_plan,0)			+ nvl(a.stm_data_cap,0)
		- nvl(a.tsys_intchg,0)			- nvl(a.assesments,0) 			+ nvl(a.dscv_discount,0) 
		- nvl(a.dscv_interchange,0)		- nvl(a.dscv_assessments,0)		+ nvl(a.pin_db_discount,0) 
		+ nvl(a.pin_db_auth_income,0) 	- nvl(a.pin_db_interchange,0) 	- nvl(a.pin_db_assessments,0) -
 		  nvl(a.pin_db_switch_fee,0)    + nvl(a.stm_feerevenue,0) 		- nvl(a.pos_fee,0))
								as CURR_YTD_DIAO
		from browser.merch_tran_info a 
		where period between &Curr_Beg_Year. and &Period.    
		group by MID );


/* MID Last YTD ( VOL, TRN, DIA, O, DIAO ) */


create table LAST_YTD as select * from connection to oracle (select 
		mid, sum(nvl(a.trancount,0)) as LAST_YTD_TRN ,
					 sum(nvl(a.netvolume,0)) as LAST_YTD_VOL ,
	   	sum(nvl(a.stm_discount,	 	0) + nvl(a.stm_surcharge,		0) 		
	 	+ 	nvl(a.stm_authrevenue, 	0) + nvl(a.stm_ind_plan,		0) 	+ nvl(a.stm_data_cap,0) 		
	 	- 	nvl(a.tsys_intchg,	 	0) - nvl(a.assesments,		 	0) 			
	 	+ 	nvl(a.dscv_discount,	0) - nvl(a.dscv_interchange,	0) 	- nvl(a.dscv_assessments,0) 
	 	+ 	nvl(a.pin_db_discount, 	0) - nvl(a.pin_db_interchange, 	0)	- nvl(a.pin_db_assessments,	0) 	- nvl(a.pin_db_switch_fee,0))
											as LAST_YTD_DIA ,
		sum(nvl(a.stm_feerevenue,0) - nvl(a.pos_fee,0)) 
											as LAST_YTD_O   ,
	  sum(nvl(a.stm_discount,0) 		+ nvl(a.stm_surcharge,0) 		- nvl(a.pin_db_auth_income,0)
		+ nvl(a.stm_authrevenue,0)		+ nvl(a.stm_ind_plan,0)			+ nvl(a.stm_data_cap,0)
		- nvl(a.tsys_intchg,0)			- nvl(a.assesments,0) 			+ nvl(a.dscv_discount,0) 
		- nvl(a.dscv_interchange,0)		- nvl(a.dscv_assessments,0)		+ nvl(a.pin_db_discount,0) 
		+ nvl(a.pin_db_auth_income,0) 	- nvl(a.pin_db_interchange,0) 	- nvl(a.pin_db_assessments,0) -
 		  nvl(a.pin_db_switch_fee,0)    + nvl(a.stm_feerevenue,0) 		- nvl(a.pos_fee,0))
											as LAST_YTD_DIAO
		from browser.merch_tran_info a
		where period between &Last_Beg_Year. and &Period_Minus_12.    
		group by MID);


/* VAS --{ EGC , ECS , DEBIT , DCC }-- */


create table EGC as select * from connection to oracle (
	select Distinct MID, 'Y' as EGC from aep.mersum_mersum where hasfrequency in ('1','Y'));

create table ECS as select *  from connection to oracle (
	select Distinct MID, 'Y' as ECS from aep.mersum_mersum where hasecc = 'Y');

create table DBT as select * from connection to oracle (
	select Distinct MID, 'Y' as DEBIT from dw.merchantcard where cardtypecode = 'DB' and captureind = '1');

create table DCC as select * from connection to oracle (
	select Distinct MID, 'Y' as DCC from browser.merch_demo_info_master where has_dcc = 'Y');
 
disconnect from oracle;

	create table &T_Name. as select a.*, 	

	coalesce(b.MID_R,0) as MID_R ,

	coalesce(c.Curr_YTD_TRN  , 0) as Curr_YTD_TRN  ,
	coalesce(c.Curr_YTD_VOL  , 0) as Curr_YTD_VOL  ,
	coalesce(c.Curr_YTD_DIA  , 0) as Curr_YTD_DIA  ,
	coalesce(c.Curr_YTD_O    , 0) as Curr_YTD_O    ,
	coalesce(c.Curr_YTD_DIAO , 0) as Curr_YTD_DIAO ,

	coalesce(d.Last_YTD_TRN  , 0) as Last_YTD_TRN  ,
	coalesce(d.Last_YTD_VOL  , 0) as Last_YTD_VOL  ,
	coalesce(d.Last_YTD_DIA  , 0) as Last_YTD_DIA  ,
	coalesce(d.Last_YTD_O    , 0) as Last_YTD_O    ,
	coalesce(d.Last_YTD_DIAO , 0) as Last_YTD_DIAO ,

	coalesceC(e.EGC,  'N')		  as EGC   ,	
	coalesceC(f.ECS,  'N')		  as ECS   ,
	coalesceC(g.DEBIT,'N')		  as DEBIT ,
	coalesceC(h.DCC,  'N')		  as DCC

	from 		&T_Name. 	a 
	left join	MID_R_RTM	b on a.mid = b.mid
	left join	CURR_YTD	c on a.mid = c.mid
	left join	LAST_YTD	d on a.mid = d.mid 
	left join 	EGC			e on a.mid = e.mid 
	left join 	ECS			f on a.mid = f.mid 
	left join	DBT			g on a.mid = g.mid 
	left join	DCC			h on a.mid = h.mid ;

/* #2  Indentify and remove MIDs who were not open during the period */
/*
	create table Closed_MIDs as select Distinct MID, 1 as Closed
	from &T_Name. where datepart(date_closed) < &Period.D and datepart(date_closed) is not null;

	create table &T_Name. as select a.*, b.Closed 
	from &T_Name. a left join Closed_MIDs b on a.mid = b.mid;

	drop table Closed_MIDs;
*/
Quit;

/*
data &T_Name. ;
 set &T_Name. ;
 if Closed then delete; Drop Closed;
Run;
*/

Proc Datasets library = Work NoList NoDetails;
	modify &T_Name.;
	index create MID ;
run;

proc sql;

/* #3a  Build the table of tax id counts */

	create table MULTI_TAX_ID as select  fedtaxid, Count(*) as TAX_CNT 
	from 	&T_Name.
	where 	coalesce(fedtaxid,'0') not in ('0', '999999999', '000000000','0000000000')  
	and		REL_TYPE not in ('AIRLN', 'HOSP', 'RM', 'HCARE','STRAT') 
Group by fedtaxid ;

/* #3b  Build the table of bank id counts */

	create table MULTI_DDA_ID as select compress(fundingaba||fundingdda) as BNK_ID,
 	Count(*) as BNK_CNT from &T_Name.
	where 	coalesce(compress(fundingaba||fundingdda),'0') ne '0' 
	and		REL_TYPE not in ('AIRLN', 'HOSP', 'RM', 'HCARE','STRAT') 
	Group by compress(fundingaba||fundingdda) ;

/* #4  left join the tax counts to the base table */

	create table &T_Name. as select a.*, b.TAX_CNT 
	from &T_Name. a left join MULTI_TAX_ID b on a.fedtaxid = b.fedtaxid ;

quit;

proc sql; drop table MULTI_TAX_ID; quit;

/* #5  Create the bank ID match key on the base table */

data &T_Name.;
 set &T_Name.;
 BNK_ID = compress(fundingaba||fundingdda);
run;

/* #6  UNI QC */

proc sort data = &T_Name. NoDupKey; by mid; run;

/* 	#7  Seperate the MIDs into three groups 
	first, Managed relationships
	second, MIDs with tax counts great than one
	last, the remaining MIDS */

data 	SMB_ID_Managed 
		SMB_ID_FEDTAXID
		SMB_ID_OTHER;
set &T_Name.;
		if Rel_Type in ('AIRLN', 'HOSP', 'RM', 'HCARE','STRAT')  then Output SMB_ID_Managed ;
else	if TAX_CNT	> 1 then output SMB_ID_FEDTAXID ;
else output SMB_ID_OTHER;
run;

/* #8  For the remaining MIDs left join the bank count */

data SMB_ID_OTHER_1 SMB_ID_OTHER_2 
	 SMB_ID_OTHER_3 SMB_ID_OTHER_4
	 SMB_ID_OTHER_5 SMB_ID_OTHER_6
     SMB_ID_OTHER_7 SMB_ID_OTHER_8
	 SMB_ID_OTHER_9 SMB_ID_OTHER_10 ;
 set SMB_ID_OTHER ;
 random = ranuni(20120214);
      if random <= 0.10 then output SMB_ID_OTHER_1 ;
 else if random <= 0.20 then output SMB_ID_OTHER_2 ;
 else if random <= 0.30 then output SMB_ID_OTHER_3 ;
 else if random <= 0.40 then output SMB_ID_OTHER_4 ;
 else if random <= 0.50 then output SMB_ID_OTHER_5 ;
 else if random <= 0.60 then output SMB_ID_OTHER_6 ;
 else if random <= 0.70 then output SMB_ID_OTHER_7 ;
 else if random <= 0.80 then output SMB_ID_OTHER_8 ;
 else if random <= 0.90 then output SMB_ID_OTHER_9 ;
 else if random <= 1.00 then output SMB_ID_OTHER_10 ;
 drop random;
run;

%macro mini_loop;
%do j = 1 %to 10;
proc sql;
	create table BNK_ID_LIST as select distinct BNK_ID, BNK_CNT
	from MULTI_DDA_ID where BNK_ID in (select distinct bnk_id from SMB_ID_OTHER_&j.);

	create table SMB_ID_OTHER_&j. as select a.*, c.BNK_CNT  
	from SMB_ID_OTHER_&j. a  left join BNK_ID_LIST c on a.BNK_ID = c.BNK_ID;
quit;
%end;
proc sql; drop table BNK_ID_LIST; quit;
%mend;
%mini_loop

proc sql; drop table MULTI_DDA_ID; quit;

data SMB_ID_OTHER;
 set SMB_ID_OTHER_1 SMB_ID_OTHER_2 
	 SMB_ID_OTHER_3 SMB_ID_OTHER_4
	 SMB_ID_OTHER_5 SMB_ID_OTHER_6
     SMB_ID_OTHER_7 SMB_ID_OTHER_8
	 SMB_ID_OTHER_9 SMB_ID_OTHER_10;
run;

proc datasets lib = work NoDetails NoList; 
	Delete 
     SMB_ID_OTHER_1 SMB_ID_OTHER_2 
	 SMB_ID_OTHER_3 SMB_ID_OTHER_4
	 SMB_ID_OTHER_5 SMB_ID_OTHER_6
     SMB_ID_OTHER_7 SMB_ID_OTHER_8
	 SMB_ID_OTHER_9 SMB_ID_OTHER_10; 
quit;

/* #9  UNI QC */

proc sort data = SMB_ID_OTHER NoDupKey; by mid; run;

/* 
	#10 ID the MIDs Relationship and Relationship Type  

	a.) Stack the three datasets, managed, tax, other 
	b.) If the MID has a previously defined relationship, keep that rel info the same 
	c.) If the MID was found to have a tax ID greater than 1, use the fed tax ID as their relationship information
	d.) If the MID was found to have a bank ID greater than 1, use the aba/dda as their relationship information
	c.) last, if no info was found, the customer is assumed to be represented by a solo account
*/

data &T_Name. ;
 set SMB_ID_Managed 
	 SMB_ID_FEDTAXID
	 SMB_ID_OTHER ;

	 	if Rel_Type in ('AIRLN', 'HOSP', 'RM', 'HCARE','STRAT')  then
							do; rel_type =  rel_type; 	Relationship = Relationship; 					 end;   
 else	if TAX_CNT > 1 then do; rel_type = 'FEDTAXID'; 	Relationship = fedtaxid;						 end;
 else 	if BNK_CNT > 1 and fundingaba ne '' and fundingdda ne ''
					   then do; rel_type = 'ABA_DDA';  	Relationship = compress(fundingaba||fundingdda); end;
 else					    do; rel_type = 'MID'; 		Relationship = MID; 							 end;
 		if REL_TYPE in ('AIRLN', 'HOSP', 'RM', 'HCARE','STRAT')  then Managed = 'Y'; else Managed ='N';
		if sponsorid = '0019' then MID_R  = 0;
		if MID_R = . then MID_R = 0;
Run;

/* #11  Clean Up */

proc datasets lib = work NoDetails NoList; 
	Delete SMB_ID_Managed SMB_ID_FEDTAXID SMB_ID_OTHER ; 
quit;

/* #12  UNI QC */

proc sort data = &T_Name. NoDupKey; by mid; run;

proc sql;

/* #13  Build Relationship Level Measurements */

	create table Rela_BC as select 
		Relationship ,
		Count(Distinct MID)				as Rel_MIDCNT ,	
		sum(coalesce(bc_trancount,0)) 	as Rel_BC_TRANCOUNT ,
		sum(coalesce(bc_volume,0)) 		as Rel_BC_VOL , 
		sum(coalesce(bc_dia,0)) 		as Rel_BC_DIA ,
		sum(coalesce(mid_dia,0)) 		as Rel_DIA ,
		sum(coalesce(mid_diao,0)) 		as Rel_DIAO ,
		sum(coalesce(mid_R,0)) 			as Rel_R
	from &T_Name.  
	group by Relationship;
quit;

/* Sort the data by BC volume within relationships */

proc sort data = &T_Name. Out = Top;
	by Relationship descending bc_volume ;
Run;

/* Keep only the first record, (highest VOL), for each relationship */

proc sort data = Top NoDupKey;
	by Relationship;
run;

data Top;
 set Top;
 Rel_Top_MID = 'Y';
run;

/* #14  Left join the CID bank card VOL */

proc sql;
	create table &T_Name. as select a.* , 
		b.Rel_MIDCNT ,	
		b.Rel_BC_TRANCOUNT ,
		b.Rel_BC_VOL , 
		b.Rel_BC_DIA ,
		b.Rel_DIA ,
		b.Rel_DIAO , 
		b.Rel_R , 
		c.Rel_Top_MID
	from &T_Name. 		a 
	left join Rela_BC 	b on a.Relationship = b.Relationship
	left join Top		c on a.mid = c.mid;
quit;

proc datasets lib = work NoDetails NoList; 
	Delete rela_bc Top ; 
quit;

/* #15  UNI QC */

proc sort data = &T_Name. NoDupKey; by mid; run;

/* 
	#16  
		Small & Medium Business Identifier
	Each MID with a CID RTM BC VOL < $5M is SMB

		Top MID Identifier
	The MID with the biggest amount of bank card VOL
*/

data &T_Name.;
 set &T_Name.;
 if Rel_Top_MID ne 'Y' then Rel_Top_MID = 'N';
 if rel_bc_vol < 5000000 then SMB = 1; else SMB = 0;
 if Tax_Cnt = .  then Tax_Cnt = 0;
 if Bnk_Cnt = .  then Bnk_Cnt = 0;
run;

/* #17  Upload file to Business Development */

proc sql;
	drop   table 	bsnsdevl.&T_Name. ;
	create table 	bsnsdevl.&T_Name. like &T_Name. ;
	insert into  	bsnsdevl.&T_Name. select * from &T_Name. ;
	drop   table	&T_Name. ;
quit;

%end;

/* 
  __  __             _   _       _          __  __             _   _        _____ _                            
 |  \/  |           | | | |     | |        |  \/  |           | | | |      / ____| |                           
 | \  / | ___  _ __ | |_| |__   | |_ ___   | \  / | ___  _ __ | |_| |__   | |    | |__   __ _ _ __   __ _  ___ 
 | |\/| |/ _ \| '_ \| __| '_ \  | __/ _ \  | |\/| |/ _ \| '_ \| __| '_ \  | |    | '_ \ / _` | '_ \ / _` |/ _ \
 | |  | | (_) | | | | |_| | | | | || (_) | | |  | | (_) | | | | |_| | | | | |____| | | | (_| | | | | (_| |  __/
 |_|  |_|\___/|_| |_|\__|_| |_|  \__\___/  |_|  |_|\___/|_| |_|\__|_| |_|  \_____|_| |_|\__,_|_| |_|\__, |\___|
                                                                                                     __/ |     
                                                                                                    |___/      

  _____                  _____ _____ _____  _       __  __ _____ _____  _     
 |_   _|                / ____|_   _|  __ \( )     |  \/  |_   _|  __ \( )    
   | |  _ __     __ _  | |      | | | |  | |/ ___  | \  / | | | | |  | |/ ___ 
   | | | '_ \   / _` | | |      | | | |  | | / __| | |\/| | | | | |  | | / __|
  _| |_| | | | | (_| | | |____ _| |_| |__| | \__ \ | |  | |_| |_| |__| | \__ \
 |_____|_| |_|  \__,_|  \_____|_____|_____/  |___/ |_|  |_|_____|_____/  |___/
                                                                              
                                                                              
*/
/*
proc sql;
	connect to oracle 
	(user=&U. password=&P. path='NEWDW01.WORLD');
	create table Full_MID_List as select * 
	from connection to oracle (select Distinct MID 
	from browser.merch_demo_info_master);
	disconnect from oracle;

	select compress("MTR"||trim(put(count(*),5.))) into :Last_DS
	from   dictionary.tables
	where  libname = 'BSNSDEVL' 
	and    memname like 'MID_TO_REL________' ;

	select compress(trim(put(count(*),5.))) into :DS_Count
	from   dictionary.tables
	where  libname = 'BSNSDEVL' 
	and    memname like 'MID_TO_REL________' ;

	select compress(memname) into :MTR1-:&Last_DS.
	from   dictionary.tables
	where  libname = 'BSNSDEVL' 
	and    memname like 'MID_TO_REL________' 
	order by memname descending;
quit ;


%do s = 1 %to 3;
%if &s. < 10 %then %do; %let var_name = 0&s.; %end;
%else %do; %let var_name = &s.; %end;
proc sql;
	create table Full_MID_List as select a.* ,
	b.Relationship	as REL_&var_name. , 
	b.Rel_Type 		as RTY_&var_name. ,
	b.Rel_MIDCNT	as RMC_&var_name. 
	From      Full_MID_List 	a
	left join bsnsdevl.&&MTR&s. b on a.mid = b.mid ;
Quit;
%end;

data Full_MID_List ;
 retain ID ID_Type Key ; 
 format Key $210. ID_Type $4. ID $36. ; 
 set Full_MID_List ;
run ;

%do r = 1 %to 3;
%if &r. < 10 %then %do; %let v_name = 0&r.; %end;
%else %do; %let v_name = &r.; %end;
data Full_MID_List ;
 set Full_MID_List ;
 Key = compress(Key||RTY_&v_name.);
run ;
%end;

%let RM_in_list =  'AIRLN', 'HOSP', 'RM', 'HCARE';

data Full_MID_List ;
 set Full_MID_List ;
 
 		if index(key,'RM')
		or index(key,'HCARE')
		or index(key,'AIRLN')
		or index(key,'HOSP')       then ID_Type = 'MGT';
 else	if index(key,'FEDTAXID')   then ID_Type = 'TAX';
 else	if index(key,'ABA_DDA')    then ID_Type = 'BNK';
 else	if index(key,'MID') 	   then ID_Type = 'MID';
 else							   	    ID_Type = 'ERR';

 if  ID_Type = 'ERR' then delete;

 if ID_Type = 'MGT' then do;
	 	if RTY_01 in (&RM_in_list.) then ID =  Rel_01 ;
 else	if RTY_02 in (&RM_in_list.) then ID =  Rel_02 ;
 else	if RTY_03 in (&RM_in_list.) then ID =  Rel_03 ;
 end;

 else if ID_Type = 'MID' then do;
	 	if RTY_01 = 'MID' then ID =  Rel_01 ;
 else	if RTY_02 = 'MID' then ID =  Rel_02 ;
 else	if RTY_03 = 'MID' then ID =  Rel_03 ;
 End;

  else if ID_Type = 'TAX' then do;
	 	if RTY_01 = "FEDTAXID" then ID =  Rel_01 ;
 else	if RTY_02 = "FEDTAXID" then ID =  Rel_02 ;
 else	if RTY_03 = "FEDTAXID" then ID =  Rel_03 ;
 End;

  else if ID_Type = 'BNK' then do;
	 	if RTY_01 = "ABA_DDA" then ID =  Rel_01 ;
 else	if RTY_02 = "ABA_DDA" then ID =  Rel_02 ;
 else	if RTY_03 = "ABA_DDA" then ID =  Rel_03 ;
 End;

 if index(key,'FEDTAXID') and index(key,'ABA_DDA')  then Quirk_ID = 1; else Quirk_ID = 0;

run ;

Proc sql;
	create table MID_CNT_by_ID as select
	ID ,
	max(RMC_01) as RMC_01 ,
	max(RMC_02) as RMC_02 ,
	max(RMC_03) as RMC_03 
	from Full_MID_List group by ID ;
quit;

data MID_CNT_by_ID ;
 set MID_CNT_by_ID ;
 RMC_Diff = RMC_01 - RMC_02  ;
 RMC_PCH  = (RMC_01 - RMC_02)/RMC_02 ;
		if RMC_02 > 0 and RMC_01  = . then CAS = '05 Cold' ;
 else	if RMC_02 = . and RMC_01  = . then CAS = 'Exclude' ;
 else	if RMC_02 =       RMC_01      then CAS = '01 Same' ;
 else	if RMC_02 = . and RMC_01  > 0 then CAS = '02 New ' ;
 else	if RMC_02 > 0 and RMC_PCH > 0 then CAS = '03 Plus' ;
 else	if RMC_02 > 0 and RMC_PCH < 0 then CAS = '04 Less' ;
run ;

proc sort data = MID_CNT_by_ID ; by CAS RMC_01 ; run;

proc sql;
	create table MID_List_v2 as select a.*, b.RMC_02 as REL_MIDCNT_LST_MTH, b.CAS as REL_MID_Alert_GRP
	from Full_MID_List a left join MID_CNT_by_ID b on a.ID = b.ID;
quit;

proc sql;
	connect to oracle 
	(user=&U. password=&P. path='NEWDW01.WORLD');
	create table Current_Month as select * 
	from connection to oracle (select *
	from BSNSDEVL.&T_Name.);
	disconnect from oracle;

	create table Current_Month as select a.*, 
		b.REL_MIDCNT_LST_MTH, 
		b.REL_MID_Alert_GRP
	from Current_Month a left join MID_List_v2 b on a.mid = b.mid;
Quit;

proc sort data = Current_Month NoDupKey; By MID; run;

proc sql;
	drop   table 	bsnsdevl.&T_Name. ;
	create table 	bsnsdevl.&T_Name. like Current_Month ;
	insert into  	bsnsdevl.&T_Name. select * from Current_Month ;
	drop   table	Current_Month ;
quit;
*/

%mend RRU_ALL;

/* 
  _______ _          
 |__   __| |         
    | |  | |__   ___ 
    | |  | '_ \ / _ \
    | |  | | | |  __/
    |_|  |_| |_|\___|

   _____ _             _   _               _____          _           _ 
  / ____| |           | | (_)             |  __ \        (_)         | |
 | (___ | |_ __ _ _ __| |_ _ _ __   __ _  | |__) |__ _ __ _  ___   __| |
  \___ \| __/ _` | '__| __| | '_ \ / _` | |  ___/ _ \ '__| |/ _ \ / _` |
  ____) | || (_| | |  | |_| | | | | (_| | | |  |  __/ |  | | (_) | (_| |
 |_____/ \__\__,_|_|   \__|_|_| |_|\__, | |_|   \___|_|  |_|\___/ \__,_|
                                    __/ |                               
                                   |___/                                

	The Starting Period 
	(It is the month before the period you want to processing)
*/

%let Starting_Period = '01MAR2015' ; %RRU_OPEN
%let Starting_Period = '01MAR2014' ; %RRU_ALL 
%let Starting_Period = '01MAR2015' ; %RRU_ALL 

FileName test EMail 'Samuel.Seibert@Elavon.com' EMAILID ='Outlook' ;

DATA _null_ ;
	File test
	SUBJECT	= "RRU is Finished"
	TO		= 'Hokaten@gmail.com'
	CC		= 'Samuel.Seibert@Elavon.com'
	;
	Put 'RRU is Finished';
	Put ' ';
RUN ;
